<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/21/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/12/21/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><h2 id="magic函数"><a href="#magic函数" class="headerlink" title="magic函数"></a>magic函数</h2><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>__construct</td><td>当一个对象创建时被调用</td></tr><tr><td>__destruct</td><td>当一个对象销毁时被调用</td></tr><tr><td>__toString</td><td>当一个对象被当做字符串使用</td></tr><tr><td>__sleep</td><td>在对象被序列化之前运行</td></tr><tr><td>__wakeup</td><td>在对象被反序列化之后被调用</td></tr><tr><td>__serialize()</td><td>对对象调用serialize方法</td></tr><tr><td>__unserialize()</td><td>对对象调用unserialize方法</td></tr><tr><td>__call()</td><td>在对象上下文中调用不可访问的方法时触发</td></tr><tr><td>__callStatic()</td><td>在静态上下文中调用不可访问的方法时触发</td></tr><tr><td>__get()</td><td>用于从不可访问的属性读取数据</td></tr><tr><td>__set()</td><td>用于将数据写入不可访问的属性</td></tr><tr><td>__isset()</td><td>在不可访问的属性上调用isset()或empty()触发</td></tr><tr><td>__unset()</td><td>在不可访问的属性上使用unset()时触发</td></tr><tr><td>__invoke()</td><td>当脚本尝试将对象调用为函数时触发</td></tr></tbody></table><h2 id="反序列化特点"><a href="#反序列化特点" class="headerlink" title="反序列化特点"></a>反序列化特点</h2><p>1.在反序列化时可以对序列化的变量进行任意修改</p><p>2.如果传递的字符串不可以序列化，则返回FALSE</p><p>3.如果对象没有预定义，反序列化得到的对象是_PHP_Incomplete_Class</p><p>4.当同时定义了wakeup()方法和unserilize()方法时，wakeup方法将不会起效，只有unserilize方法会起作用</p><h2 id="反序列化作用"><a href="#反序列化作用" class="headerlink" title="反序列化作用"></a>反序列化作用</h2><p>1.传输对象</p><p>2.用作缓存(cookie,session)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>YL渗透日记</title>
    <link href="/2023/12/16/YL%E6%B8%97%E9%80%8F%E6%97%A5%E8%AE%B0/"/>
    <url>/2023/12/16/YL%E6%B8%97%E9%80%8F%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="浏览器查找"><a href="#浏览器查找" class="headerlink" title="浏览器查找"></a>浏览器查找</h2><table><thead><tr><th align="center">关键字</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Site</td><td align="center">指定域名</td></tr><tr><td align="center">Inurl</td><td align="center">url中存在指定关键字的网页</td></tr><tr><td align="center">Intext</td><td align="center">网页正文中的关键字</td></tr><tr><td align="center">Filetype</td><td align="center">指定文件的类型</td></tr><tr><td align="center">Intitle</td><td align="center">网页标题中的关键字</td></tr><tr><td align="center">link</td><td align="center">返回所有与后面跟的url有链接的url</td></tr><tr><td align="center">Info</td><td align="center">查找指定站点的一些基本信息</td></tr><tr><td align="center">cache</td><td align="center">搜索谷歌里关于一些内容的缓存</td></tr></tbody></table><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>在对端口进行扫描之后，我们可以知道该服务器上提供的服务以及可能存在的便于我们攻击的点，但是得先掌握一些常用端口的常提供的服务以及可能存在的攻击位置<img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153547.png"></p><p><img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153604.png"></p><p><img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153616.png"></p><p><img src="C:\Users\Lenovo\Pictures\Screenshots\QQ截图20231127153625.png"></p><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>利用网站的cms我们可以查验是否存在一些常见漏洞，常见工具可以使用kali自带的whatweb工具</p><p>使用方法为whatweb url 也可以加上-v来显示详细信息</p><p>具体内容移步至</p><p>渗透测试信息收集-CMS指纹识别 - h4m5t的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/355150689">https://zhuanlan.zhihu.com/p/355150689</a></p><h2 id="查找真实ip"><a href="#查找真实ip" class="headerlink" title="查找真实ip"></a>查找真实ip</h2><h3 id="ip地址划分"><a href="#ip地址划分" class="headerlink" title="ip地址划分"></a>ip地址划分</h3><p>&lt;一个域名只能对应一个ip,但是一个ip可以对应多个域名&gt;</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">公网地址<br>​ <span class="hljs-keyword">A</span>类：<span class="hljs-number">1.0.0.0</span> - <span class="hljs-number">126.0.0.0</span> <span class="hljs-number">255.0.0.0</span><br>​ B类：<span class="hljs-number">128.0.0.0</span> - <span class="hljs-number">191.255.255.0</span> <span class="hljs-number">255.255.0.0</span><br>​ C类：<span class="hljs-number">192.0.0.0</span> - <span class="hljs-number">223.255.255.0</span> <span class="hljs-number">255.255.255.0</span><br>​ D类：<span class="hljs-number">224.0.0.0</span> - <span class="hljs-number">239.255.255.255</span> （多播地址）<br>​ E类：<span class="hljs-number">240.0.0.0</span> - <span class="hljs-number">247.255.255.255</span> （保留地址）<br><br>私有地址<br>​ <span class="hljs-number">10.0.0.0</span> - <span class="hljs-number">10.255.255.255</span><br>​ <span class="hljs-number">172.16.0.0</span> - <span class="hljs-number">172.31.255.255</span><br>​ <span class="hljs-number">192.168.0.0</span> - <span class="hljs-number">192.168.255.255</span><br></code></pre></td></tr></table></figure><h3 id="CDN基础介绍"><a href="#CDN基础介绍" class="headerlink" title="CDN基础介绍"></a>CDN基础介绍</h3><p><strong>CDN：Content Delivery Network 内容分发网络</strong></p><p>CDN可以理解为一种虚拟网络,将很多静态资源放在节点服务器上,以减少web服务器的负担,通常访问较大网站都会直接从CDN上给我们发放资源,用户可以直接通过就近的节点服务器访问这部分资源，而不用通过web服务器，当用户有实际数据进行交互的时候才会访问Web服务器，因此CDN可以降低网络拥塞，提高响应速度。</p><p><strong>简单理解就是CDN能够让用户访问就近的节点服务器</strong></p><p>所以有可能我们查询到的ip其实是该网站CDN的ip地址</p><h4 id="判断是否存在CDN"><a href="#判断是否存在CDN" class="headerlink" title="判断是否存在CDN"></a>判断是否存在CDN</h4><p>从不同省份ping同一个域名，查看响应的ip地址是否相同，不同的话就说明存在CDN且多个CDN在同时工作</p><h4 id="绕过CDN"><a href="#绕过CDN" class="headerlink" title="绕过CDN"></a>绕过CDN</h4><h5 id="以下为查询资料得到的几种常见方式"><a href="#以下为查询资料得到的几种常见方式" class="headerlink" title="以下为查询资料得到的几种常见方式"></a>以下为查询资料得到的几种常见方式</h5><p>1.使用phpinfo()，可以查看本地的ip地址以及使用端口</p><p>2.或者使用一点神奇的小玩意，比如这个网站 https:&#x2F;&#x2F;<a href="https://so.csdn.net/so/search?q=asm&spm=1001.2101.3001.7020">asm</a>.ca.com&#x2F;en&#x2F;ping.php，可以从国外来ping我们需要查询的url，这样就避免了国内CDN的误导</p><p>3.ping顶级域名<br>也可以在线网站ping顶级域名，若得到多个IP，在fofa上逐一输入IP进行验证（或用view-source的方式）</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231213110027197.png" alt="image-20231213110027197"></p><p>发现ping baidu.com，返回的第一条信息是 Ping baidu.com …</p><p>ping <a href="http://www.baidu.com/">www.baidu.com</a> 返回的第一条信息是 Ping <a href="http://www.a.shifen.com/">www.a.shifen.com</a> 和用户输入的域名不同。<a href="http://www.a.shifen.com/">www.a.shifen.com</a> 是CDN的地址 </p><p>4.一般的邮件系统都在内部，没有经过CDN的解析，<strong>通过目标网站用户注册或者RSS订阅功能，查看邮件，寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名</strong>，就可以获得目标的真实IP(必须是目标自己的邮件服务器，第三方或者公共邮件服务器是没有用的)</p><p>5.查看子域名</p><p>  往往流量少的子域名不会使用CDN，用户直接访问，就能得到真实的IP地址</p><p>案例一</p><p><a href="http://www.taobao.com/">www.taobao.com</a> 是淘宝网的主页</p><p>talent.alibaba.com 是阿里巴巴网上招聘的主页</p><p>nslookup 解析 talent.alibaba.com</p><p>经过view-source验证，结果 招聘主页解析的IP地址 就是 淘宝网的真实IP地址</p><p><img src="https://img-blog.csdnimg.cn/2021071717560838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY4NDU3OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>案例二</p><p>有时候没办法直接用IP地址访问网页，但是可以用fofa的方式</p><p><img src="https://img-blog.csdnimg.cn/20210717180103170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY4NDU3OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>若一个子域名找不到，尝试多个子域名，根据IP地址的分类（A,B,C类等）确定域名对应的IP</p><p>例如查看京东的 help.jd.com jr.jd.com等，ping这些url的时候，返回的都是cnd，因此可以排除</p><p>jd.com gift.jd.com authcode.jd.com 等子域名 用全球ping网站进行测试，找共用的IP</p><p>如果有共用的IP，然后将得到的IP 在fofa上查询，能够找到对应的子域名，证明这些IP时真实的，不是CDN</p><p>6.查询资料得</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//crt.sh 此网站通过域名查找对应的SSL证书的 HASH值（SHA-256）</span><br><br>Censys：https:<span class="hljs-comment">//search.censys.io/certificates?q= 此网站通过Hash(SHA-256)得到真实IP</span><br></code></pre></td></tr></table></figure><p>但是根据gpt查找原理又称其不成立,理由如下:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">通过Hash(SHA<span class="hljs-string">-256</span>)得到真实IP的原理是不可能的。SHA<span class="hljs-string">-256</span>是一种单向哈希函数，它将输入数据转换为固定长度的哈希值，具有以下特性：<br>不可逆性：对于给定的哈希值，几乎不可能从哈希值反推出原始输入数据。<br>唯一性：不同的输入数据通常会产生不同的哈希值，但相同的输入数据将始终产生相同的哈希值。<br>因此，通过SHA<span class="hljs-string">-256</span>哈希函数无法直接获取到原始数据（例如真实IP地址）。哈希函数常用于数据完整性验证、密码存储等场景，但不能用于反向推导出原始数据。<br></code></pre></td></tr></table></figure><p>7.域名解析:</p><p>使用命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nslookup</span><br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">第一部分：<br>解析baidu.<span class="hljs-keyword">com</span> 的 服务器url 和 IP地址<br>第二张图中的address：<span class="hljs-number">192.168</span>.<span class="hljs-number">54.38</span> 是本地局域网的网关<br><br>第二部分—非权威应答：<br>第一次请求的DNS服务器没有 baidu.<span class="hljs-keyword">com</span> 对应的IP地址，无法解析。此DNS服务器会通过迭代递归的方式从百度公司实际存储此记录信息的DNS server中获取baidu.<span class="hljs-keyword">com</span>的IP，然后返回给用户，同时客户端会把baidu.<span class="hljs-keyword">com</span>的信息放在本地记录一段时间。<br>当用户再次解析baidu.<span class="hljs-keyword">com</span>的时候，会直接从本地缓存中解析并返回，这个过程叫非权威应答。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210717175627590.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210717175722580.png#pic_center" alt="在这里插入图片描述"></p><p>8.还有一个反向查询ip网站来解析域名：<a href="http://www.viewdns.com/">www.viewdns.com</a></p><p>9.网站漏洞</p><p>利用网站自身存在的漏洞，很多情况下会泄露服务器的真实IP地址（仅适用于傻狗网站）</p><h4 id="验证是否查找到真实ip"><a href="#验证是否查找到真实ip" class="headerlink" title="验证是否查找到真实ip"></a>验证是否查找到真实ip</h4><h5 id="1-view-source验证"><a href="#1-view-source验证" class="headerlink" title="1.view-source验证"></a>1.view-source验证</h5><p>在浏览器中地址栏输入view-source加我们需要验证的ip地址，如果出现了正确的图标，整证明找到的IP 地址是真实的</p><h5 id="2-fofa验证"><a href="#2-fofa验证" class="headerlink" title="2.fofa验证"></a>2.fofa验证</h5><p>输入最有可能是真实的IP地址，查看网页正文信息，或者直接输入IP，看fofa上是否显示对应的域名</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>首先ping顶级域名，将返回的IP地址进行验证</li><li>尝试国外ping，看域名解析返回的信息</li><li>查找子域名IP（淘宝和阿里招聘是同一个IP），结合看解析返回的信息</li><li>历史域名解析</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web渗透部分复现</title>
    <link href="/2023/12/16/web%E6%B8%97%E9%80%8F%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/12/16/web%E6%B8%97%E9%80%8F%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="web基础思路总结"><a href="#web基础思路总结" class="headerlink" title="web基础思路总结"></a>web基础思路总结</h2><p>一个菜鸟的简单渗透日记</p><h3 id="常见SQL思路"><a href="#常见SQL思路" class="headerlink" title="常见SQL思路"></a>常见SQL思路</h3><h4 id="1-堆叠注入"><a href="#1-堆叠注入" class="headerlink" title="1.堆叠注入"></a>1.堆叠注入</h4><p>  遇到题目就只给单独一个输入框然后进行查询的，直接考虑堆叠注入，一套不解释连招秒了╰(<em>°▽°</em>)╯</p><p>  堆叠注入</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">第一步:常规判断闭合&lt;只要给界面搞报错就是成功了&gt;</span><br><span class="hljs-section">第二步:构造语句查询库名和表名,以单引号闭合题目为例&lt;1&#x27;;show databases;#&gt;注意这里database后面要加s</span><br><span class="hljs-section">第三步:当我们找到表名之后要尝试将其打开,这是要使用函数handler</span><br><span class="hljs-section">补充handler用法:</span><br>HANDLER tbl_name OPEN; 打开一张表<br>HANDLER tbl_name READ FIRST/NEXT; 获取表中的第一行,FIRST(第一行)、NEXT(下一行)<br>当表名里有数字时要用反引号框起来<br></code></pre></td></tr></table></figure><p>可练习题目见</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">强网杯-随便注   <br></code></pre></td></tr></table></figure><h3 id="2-空格过滤方法"><a href="#2-空格过滤方法" class="headerlink" title="2.空格过滤方法"></a>2.空格过滤方法</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel">$IFS              <br>$IFS$6                               ——后面的数字<span class="hljs-number">6</span>换成其他数字也行<br>$&#123;IFS&#125; <br>&lt;<br>&lt;&gt;<br>&#123;cat,flag.php&#125;                      ——这里把，替换成了空格键<br>%20                                     ——代表space键<br>%09                                     ——代表Tab键<br></code></pre></td></tr></table></figure><h3 id="3-Windows和Linux通用命令分隔符"><a href="#3-Windows和Linux通用命令分隔符" class="headerlink" title="3.Windows和Linux通用命令分隔符"></a>3.Windows和Linux通用命令分隔符<ping ping ping></h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">; : 命令<span class="hljs-number">1</span> ; 命令<span class="hljs-number">2</span>                  ——先执行命令<span class="hljs-number">1</span>再执行命令<span class="hljs-number">2</span><br><span class="hljs-meta">&amp; ：命令1 &amp; 命令2              ——先执行命令1再执行命令2</span><br><span class="hljs-string">| ： 命令1 &amp; 命令2               ——只执行命令2</span><br></code></pre></td></tr></table></figure><p>在知道命令分隔符的前提下,我们可以实现一种很神奇的绕过</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205174259364.png" alt="image-20231205174259364"></p><p>可以看见,我们使用分隔符|实现只执行第二个命令<ls> 即列出该目录下所有的文件</p><p>然后可见flag.php这个文件,答案就在眼前,但是当我们构造出查看该文件的命令时,却出现了这样一幕:</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205174542569.png" alt="image-20231205174542569"></p><p>很显然,我们的空格被过滤了＞﹏＜</p><p>用上刚学的空格过滤,我们发现还是打不开这个文件,于是退而求其次,看看另一个文件 里面是什么东西</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205174851323.png" alt="image-20231205174851323"></p><p>发现了源码,发现了一堆被过滤的东西ಥ_ಥ</p><p>这时候就有几种方式来进行绕过了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span>.拼接法绕过<br>  通过源码我们知道过滤了flag这四个字母,这个方法主要是绕过对flag正则匹配的检测，有点悬，目前好像只能拼接末尾的g\ag\lag，我也不太清楚为啥<br>  将lag替换成x，绕过对flag的正匹检测，构建payload<br>  inurl?ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;x=lag;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$6f</span><span class="hljs-variable">$x</span>.php&lt;ip中的<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>可以替换为任意数&gt;<br><span class="hljs-number">2</span>.内联执行法<br>可以看到代码没有过滤掉符号`  ， 所以可以利用内联执行的方式直接打开flag文件<br>先执行命令<span class="hljs-built_in">ls</span>，再把<span class="hljs-built_in">ls</span>得到的文件名全部用命令<span class="hljs-built_in">cat</span>打开，构建payload <br>inurl?ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$6</span>`ls`<br></code></pre></td></tr></table></figure><h3 id="4-文件包含类"><a href="#4-文件包含类" class="headerlink" title="4.文件包含类"></a>4.文件包含类<Warm up></h3><p>常规看源码或者检查网络可以看到一些小提示，比如某个奇怪的文件(●’◡’●)，这时候就可以尝试我们的文件包含</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205211154100.png" alt="image-20231205211154100"></p><p>就像这样，访问该文件，如果发现有<strong>include</strong>函数，实锤</p><h4 id="warm-up-wp："><a href="#warm-up-wp：" class="headerlink" title="warm up wp："></a><strong>warm up</strong> wp：</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">可以看到<span class="hljs-keyword">include</span>函数没有任何过滤措施，那么我们可以利用本地文件包含漏洞来访问任意文件，以获取flag，但是想要执行<span class="hljs-keyword">include</span>函数，我们需要满足三个条件：<br><br><span class="hljs-number">1</span>. <span class="hljs-keyword">file</span>不为空<br><span class="hljs-number">2</span>. <span class="hljs-keyword">file</span>的值是字符串<br><span class="hljs-number">3</span>. <span class="hljs-keyword">file</span>通过emmm类的checkFile方法校验<br>步骤一：因为我们定义了<span class="hljs-keyword">file</span>的值且是<span class="hljs-keyword">string</span>类型，所以第一个<span class="hljs-keyword">if</span> 的<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> 顺利绕过<br>步骤二：因为我们的<span class="hljs-keyword">file</span>的值既不是souce.php也不是hint.php，所以是无法通过该<span class="hljs-keyword">if</span>的，直接放弃这个<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>的机会，继续往下看。<br>步骤三：mb_substr会将<span class="hljs-keyword">file</span>的值通过一定的规则截取后，再次放入<span class="hljs-keyword">if</span>判断，那么我们可以在<span class="hljs-keyword">file</span>的值前面主动拼接一个souce.php?或者hint.php?，也就是<span class="hljs-keyword">file</span>=source.php?../ffffllllaaaagggg，通过mb_substr截取后的值是souce.php，此时checkFile返回<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>附上source.php源码截图</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205214739670.png" alt="image-20231205214739670"></p><h3 id="5-PHP伪协议"><a href="#5-PHP伪协议" class="headerlink" title="5.PHP伪协议"></a>5.PHP伪协议<Secret File></h3><h4 id="Secret-File-wp："><a href="#Secret-File-wp：" class="headerlink" title="Secret File wp："></a>Secret File wp：</h4><p>这道题开局有个小心机，有个按键被设置为和背景颜色一致，需要养成全选界面的好习惯，发现之后点击，会发现最后一个界面说的是没看清吗?,这时候就需要抓包(界面如下)来查看中间的一个文件是什么玩意,进入之后代码如下</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205215130127.png" alt="image-20231205215130127"></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205215253604.png" alt="image-20231205215253604"></p><p>访问该flag.php文件</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231205215405300.png" alt="image-20231205215405300"></p><p>查看源码也发现不了任何的东西,因为php代码被执行之后是不会再显示出来的ヾ(•ω•&#96;)o</p><p>其实,在我们发现<strong>flag.php</strong>这个神奇文件的时候,第一反应应该是这是一道<strong>PHP伪协议</strong>题</p><p>下面是一种我掌握的<strong>PHP伪协议</strong>用法(有新的继续补充)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">在后面加上<br><br>?<span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=flag.php即可。<br><br>这是因为 php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode 是一种 PHP 伪协议，用于将文件转换为 base64 格式。通过在 <span class="hljs-variable">$_GET</span> 超全局变量中传递 <span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=flag.php，我们可以读取 flag.php 文件的内容并将其转换为 base64 格式。然后，我们可以将该内容解码并查看其中是否包含有用的信息。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/16/hello-world/"/>
    <url>/2023/12/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
